# Linux_note
리눅스 수업 필기 
https://cafe.daum.net/studyitworld/cH1T

## 251112 수 ##
- 리눅스 
오픈소스 운영체제중 하나
성능이 낮은 컴퓨터에서도 잘 돌아감

- 특징
오픈소스 운영체제
누구나 자유롭게 소스코드를 수정하고 배포할 수 있음
그니까 누구나 자유롭게 리눅스를 활용하여 다양한 배포판을 생산가능

- 안정성과 신뢰성
오랜기간동안 전세계 다양한 개발자들의 손을 거쳐 지속적으로 개선되고 있어서 높은 안정성과 보안 기능을 보장함
윈도우보다 시스템이 가볍고 최적화되어있어서 오류 발생 적음
GUI: 그래픽 사용자 인터페이스라는 뜻
CLI: 커맨드 라인 인터페이스로 터미널을 통해 사용자와 컴퓨터가 상호작용을 함

- 멀티유저 및 멀티태스킹 지원
멀티유저 뜻 : 여러 사용자가 동시에 시스템을 사용 할 수 있다.
멀티태스킹 : 여러 개의 프로세스를 동시에 실행할 수 있다.

- 강력한 보안성
사용자 및 그룹 권한 관리를 좀 더 세밀하게 설정이 가능함
업데이트 빠름

- 무료
라이선스 비용이 없음

- 최초의 리눅스 배포판 :  SLS
버그가 다소 많았고 어려웠음

- 슬랙웨어
얜 버그를 잡기 위해 개발되었고 안정성과 단순성을 목표로 만들어졌음
타 리눅스 배포판과는 다르게 그래픽 기반의 설치 절차가 없다.
소프트웨어 패키지의 의존성도 자동으로 해결해 줌

- 데비안
우분투, 칼리 리눅스, 라즈비안 등의 기반이 되는 배포판

- 우분투와 데비안의 관계
우분투는 데비안을 기반으로 하는 배포판이다
데비안의 소스코드를 사용하면서도 사용자 친화적인 설치 과정, 장기적인 업데이트 지원 등을 통해 사용자 경험을 높이는데 초점을 맞춤
서버 클라우드 환경에서 널리 사용되며 가장 인기있는 리눅스 배포판 중 하나이며 초심자들이 접하기 좋은 리눅스

- 레드햇
기업용 서버로 가장 인기가 많음
안정성과 보안성이 뛰어나 기업, 공공기관, 서버에서 많이 사용됨

- 레드햇 계열  데비안 계열
패키지 관리
래드햇 계열 : yum   		데비안 계열 : apt
REHL은 유료

---------------------------
윈도우와 리눅스 비교 분석
1. 운영체제
windows  서버는 ms사의 운영체제인  windows Server 운영 체제를 사용하고
Linux 서버는 여러가지 배포판을 사용하는 Linux 운영체제를 사용한다
윈도우는 상대적으로 비싸지만 Linux는 오픈소스로 무료로 사용가능하며 서버비용이 저렵하다

2. 사용자 인터페이스
Window 서버는 gui 를 사용하여 사용자가 마우스와 키보드를 통해 작업을 수행할 수 있다
반면에 Linux 서버는 주로 명령 줄 인터페이스를 사용하여 텍스트 명령어를 입력하여 작업을 수행한다

3. 소프트웨어 지원
Window는 MS사의 제품군에 최적화되어있다.
Linux 서버는 오픈소스 생태계에 특화되어 있으며 오픈소스 소프트웨어 및 개발 도구를 널리 지원한다

4. 호환성
Window 서버는 MS의 다른 제품군과의 완벽한 호환성을 제공한다
NET 프레임워크 등과 같은 MS 플랫폼과의 통합이 원활하다.
Linux 서버는 다양한 프로토콜과 표준을 준수하며 다른 운영체제와의 호환성이 높다

리눅스 서버 채택 / 윈도우 서버를 채택
윈도우 서버:
.net 기반 웹 애플리케이션 사용(asp, c#, winform, wpf)
ms 제품과의 연동이 필수적일때

리눅스 서버:
 Apache,Nginx 운영
클라우드 서버 (AWS, GCP, Azure)
보안과 안정성이 중요한 데이터센터 운영

- 가상화란?
하나의 물리적 서버나 기기의 자원을 소프트웨어로 분할하여 각각 독립적인 환경에서 여러개의 가상머신을 동시에 실행하는 기술

- 가상머신
실제하는 컴퓨터 상에 소프트웨어로 논리적으로 만들어낸 컴퓨터
하나의 물리자원 위에 또 다른 os를 새로 설치하는 기법

- 왜 가상머신을 사용할까
실제로 있는 컴퓨터 시스템을 여러명의 사용자가 동시에 사용할 수 있게 하기 위함
따라서 하나의 컴퓨터를 여러명의 사용자가 동시에 사용할 수 있도록
여러 대의 작은 컴퓨터로 분할 사용하거나
운영체제나 하드웨어 등의 구성을 달리 하여 운영하고자 할때 주로 사용된다

- 가상머신 종류
VMware, Virtual Box
=========================================================================================

## 251114 금 ##
1. 우분투 다운로드
2. 
가상머신 (vm player) 키고 putty 들어가기
jisun
123456
=========================================================================================

## 251117 월 ##
저번 시간에 슈퍼유저 생성함
sudo passwd root --> root 계정의 비밀번호 설정
su root --> root 계정으로 접속 변경

sudo 
- 리눅스에서 root 계정으로 직접 로그인하지 않고 일반 사용자가 sudo 명령어를 사용하여 일시적으로 슈퍼유저의 권한으로 작업을 실행할 수 있다.
su
- 슈퍼유저 계정으로 전환하기 위한 명령어

슈퍼유저 권한
1. 사용자 등록 및 삭제
2. 소프트웨어 설치, 업그레이드, 삭제
3. 하드웨어 추가 설치
4. 시스템 보안
5. 데이터 백업
---------------------------------------------------------------------------------------
date : 날짜 및 시간확인
hostname : 내가 사용하고 있는 호스트(컴퓨터)의 이름을 확인할 수 있다.
uname : 현재 사용하고 있는 운영체제를 확인할 수 있다.
uname -a : -a 옵션과 함께 실행하면 운영체제뿐만 아니라 호스트 이름, 시스템 사양을 함께 보여준다. 
whoami : 현재 로그인한 사용자의 아이디를 보여준다.
pwd : 현재 작업 디렉토리에 절대 경로명을 출력한다.

파일과 디렉토리
- 리눅스에는 일반파일, 디렉토리, 장치파일, 심볼릭 링크 등 여러 종류의 파일이 있다.
  일반파일 : 데이터를 가지고 있으면서 디스크에 저장되는 파일
            텍스트 파일 혹은 이진 파일(이미지, 동영상)과 같은 파일은 모두 일반 파일로 취급
            텍스트 파일은 cat 명령어로 내용을 볼 수 있고 vi, nano와 같은 텍스트 편집기로 내용 수정 및 작성이 가능하다. 
  디렉토리 : 파일들을 계층적으로 조직화하는 데 사용되는 일종의 특수 파일
            디렉토리의 내용은 그 디렉토리 내에 있는 파일이나 서브 디렉토리의 이름
  장치파일 : 시스템에 부착된 주변 장치를 나타내는 특수 파일이다.
            하드디스크, DVD 드라이브, 프린터 등 시스템에 부착된 대부분의 장치를 장치 파일 형태로 관리한다.
  심볼릭 링크 : 어떤 파일을 가리키는 또 하나의 경로명을 저장하는 파일로 기존 파일을 가리키는 포인터와 같은 역할을 함.(=바로가기기능)

디렉토리 구조
/ : 최상위 디렉토리이며, 리눅스의 모든 디렉토리들의 시작점
    절대경로의 기준이 되는 디렉토리 
/bin : 기본적인 명령어가 저장된 디렉토리 
/boot : 리눅스 부트로더가 존재하는 디렉토리
        GRUB와 같은 부트로더에 관한 파일들이 존재   
        (GRUB란, 시스템 부팅 과정에서 디스크의 커널을 메모리로 불러와 실행하는 역할을 함.)
        부팅에 관한 구성들이 포함되어 있다. 
/dev : 시스템 디바이스 파일을 저장
       cd-rom, 마우스, 키보드 등 장치 파일들이 존재하는 디렉토리
/etc : 시스템의 전체 설정 파일이 존재
/home : 사용자 홈 디렉토리 -> 로그인 시 처음 위치하는 디렉토리 경로
        사용자를 새로 만들면 /home 아래로 사용자 아이디 명으로 디렉토리 생성됨
/lib : 프로그램들이 의존하고 있는 라이브러리 파일들이 존재
/mnt : 탈부착이 가능한 장치들
/opt : 응용프로그램이 설치되는 디렉토리
/root : 시스템 최고 고나리자인 root 사용자의 개인 디렉토리
        사용자 디렉토리와 따로 분류됨 !!
/lost+found : 윈도우의 휴지통과 같은 개념
/var : 가변파일들을 저장
       부팅과정을 기록

- 절대경로 : 대상파일이나 디렉토리까지의 경로 이름을 root 디렉토리부터 시작하여 정확하게 명시하는 것 (주로 사용)
- 상대경로 : 파일이나 디렉토리의 경로 이름의 현재 작업 디렉토리부터 시작하여 기술한다.
            '.' : 현재 디렉토리를 의미
            '..' : 부모 디렉토리를 의미       ex) cd ../../../
            '~' : 홈 디렉토리로 이동 (어느 경로에 있든지 사용자 홈 디렉토리로 이동한다.)

man 명령어 : 명령어의 사용법과 옵션등을 보여주는 메뉴얼 도구
            man 명령어 뒤에 원하는 명령어 이름을 붙혀 실행하면 해당 명령어에 대한 상세정보를 얻을 수 있다.
ls 명령어
- 리눅스의 ls  명령어는 list의 줄임말로 현재 위치나 특정 경로의 디렉토리 내용을 리스트로 출력하는 명령어
- ls 명령어는 기본 알파벳 순으로 출력된다.
- ls 명령어는 현재 및 특정 경로에 위치를 출력한다.

ls 명령어 주요 옵션
-a : 숨겨진 파일을 포함하여 모든 파일을 리스트 한다.
-s : 파일의 크기를 KB 단위로 출력한다.
-l : 파일의 상세 정보를 출력한다.
-F : 파일의 종류를 표시하여 출력
-R : 모든 하위 디렉토리들을 리스트한다.
-al : a + l의 조합, all의 줄임말로 모든 파일(숨김 파일 및 디렉토리 포함) 하여 상세정보 출력.

mkdir 명령어 : 새 디렉토리를 만드는 명령어로 명령줄 인수로 명시한 디렉토리를 새로 만든다.
rmdir 명령어 : 디렉토리를 삭제 (단, 디렉토리 내에 아무것도 없어야 함)

rm -i 디렉토리 명 : 내용있는 파일 삭제 명령어어

cat 명령어 : - 리눅스에서 텍스트 파일의 내용을 화면에 출력하는 명령어
            - 연결시키다. 연관시키다 라는 등의 뜻을 가지고 있다. 
            - cat 명령어는 여러 파일을 입력으로 사용하거나 |, > 와 결합하여 다른 파일과 프로그램을 연결할 때 사용할 수 있다.
            - cat > 파일명 => 표준입력 내용을 모두 파일에 저장한다. 만약 파일이 없다면 새로 만듦
                              내용을 작성하고 나갈 때는 ctrl + D 를 입력  
touch 명령어 : touch 명령어를 이용하면 파일 크기가 0인 빈 파일을 만들 수 있다. 

======================================================================================================

## 251119 수 ##
vi 에디터 : 크게 두 가지 모드가 있는데 명령모드와 입력모드로 나뉨.
명령모드 : 입력하는 모든 것이 vi 명령어로 해석된다. vi 명령어는 커서를 움직이는 명령, 입력모드로 전환하는 명령, 수정, 삭제 명령 등이 있다. 
입력모드 : 명령모드에서 텍스트를 입력하고자 하는 곳으로 커서를 옮긴 후 입력 모드를 전환 명령어를 사용하여 입력 모드로 전환을 하고 텍스트 입력 후 ESC 키를 이용하여 다시 명령모드로 되돌아옴

 vi : 원하는 위치로 이동 
 h : 커서 한 칸 왼쪽 이동
 j : 커서 한 칸 아래쪽 이동
 k : 커서 한 칸 위쪽 이동
 l : 커서 한 칸 오른쪽 이동
 backspace : 왼쪽으로 한 칸 이동
 shift + space : 오른쪽으로 한 칸 이동
 - : 이전 줄의 처음으로 커서 이동
 + : 다음 줄의 처음으로 커서 이동
 0 : 현재 라인의 맨앞으로 커서 이동
 $ : 커서가 위치한 라인의 맨 끝으로 이동
 w : 단어의 첫 글자로 이동
 b : 이전 단어의 첫 글자로 이동
 gg : 문서의 맨 첫 줄로 이동
 shift + g : 마지막 줄로 이동
 :n => 지정한 숫자 라인에 커서 이동

 cw : 현재 커서가 위한 곳의 단어를 삭제
 cc : 현재 줄 삭제하고 삽입 상태로 변경

 a : 커서 위치 뒤에 삽입 
 A : 현재 줄의 뒤에 삽입

 x : 커서가 있는 문자 지우기
 shift + d : 커서가 위치한 곳부터 줄의 끝까지 지움
 dd : 현재 줄 전체 지우기

 :wq => 현재 파일에 저장하고 종료
 :q! => 작업 내용을 저장하지 않고 강제 종료

 //(sudo apt update -> sudo apt install build-essential -> gcc --version)

GCC 란? 
: GNU 프로젝트의 일환으로 개발되어 널리 쓰이고 있는 컴파일러이다. 원래 C언어만 지원하였으나 점차 다양한 언어로 확대되고 있다. 
- 오픈소스 소프트웨어로 누구나 코드를 수정하고 배포할 수 있다.

컴파일러 : 프로그램 전체를 모두 기계어로 한번에 번역 (속도가 더 빠름)
         컴파일러 언어는 컴파일러를 통해 컴파일 타임에 전체 소스코드를 한번에 기계어로 변환 후 실행파일을 만든다.
인터프리터 : 소스코드를 한줄 한줄 인터프리터가 번역하여 실행
          컴파일하는 과정이 없고 컴파일 하는 시간은 소요되지 않으나 매 실행시 마다 인터프리터 과정이 반복되어 컴파일러 언어보다 실행속도가 느리다. 
패키지 매니저 : 개발을 하면서 뭔가를 설치할 때, pip, npm 등 명령어를 사용한다. 
            패키지란 라이브러리와 비슷한 개념이다. 라이브러리는 특정한 기능을 위해 미리 만들어 놓은 코드의 집합, 이러한 라이브러리를 다른 사람들이 쓸 수 있게끔 잘 포장되어 있는 걸 패키지라고 한다. 
  
code
vi hello.c ->
#include <stdio.h>
void main () {
      printf("Hello World\n");
} -> :wq -> gcc hello.c -o hello -> ls -l -> ./hello => Hello World
-> witch gcc => /usr/bin/gcc => gcc 확인 
=================================================================================================

## 251124 월 ##
패키지 매니저의 주요 특성
1. 자동화된 설치 및 업데이트
: 명령어를 입력하여 원하는 패키지를 한번에 설치 및 업데이트와 삭제를 할 수 있다.
2. 의존성 관리
: 참조된 여러 패키지 간에 복잡학 의존성을 자동으로 해결하고 관리
3. 버전관리
: 특정 패키지의 버전을 명확하게 지정하고 관리할 수 있다.

의존성 : 소프트웨어 구성 요소가 다른 구성요소의 기능을 사용하거나 필요로 하는 관계!!
        모듈 클래스 함수가 다른 요소에 의존하여 동작하는 상황

sudo apt update: 설치가 가능한 패키지 리스트만 최신화 하는것
sudo apt list --installed : 시스템 패키지 목록을 조회한다.
sudo apt upgrade : 라이브러리를 업데이트 함!

파일복사 : cp -> cp 명령어는 파일 복사를 위한 명령어로 기존 파일을 복사하여 새로운 파일을 만듦. 
cp 기존파일명 새로운 파일명 
cp -i : 대화형 옵션을 사용하여 보다 안전하게 명령어를 사용할 수 있다.

파일이동 : mv -> mv 명령어는 파일 이름 변경 혹은 파일 이동을 위한 명령어임

파일삭제 : rm -> 파일 삭제를 위한 명령어로 명령줄 인수로 받은 파일을 삭제한다.
                파일을 지워서 없애버리므로 매우 위험함
          옵션 
          -r : 재귀삭제 즉) 디렉토리 안에 모든 파일과 폴더를 전부 삭제
          -f : 강제삭제 즉) 묻지도 따지지도 않고 전부 삭제 cw : 현재 커서가 위한 곳의 단어를 삭제
          -i : 대화형 옵션 !!
          * -r과 i 옵션을 조합해서 안전하게 삭제할 수 있다.
          
zip 명령어 : 파일이나 디렉토리 등 압축할 때 사용하는 명령어
 사용예시) zip 압축파일명 기존파일명 ,
upzip 명령어 : 파일이나 디렉토리 압축을 해제할 때 사용하는 명령어
 사용예시) unzip 압축파일명 -d /test/압축해제할디렉토리/해제했을때디렉토리

drwxr-xr-x 2   root     root   4096 Nov 24 20:36   mkd
(접근권한)     (소유자)  (그룹)                     (파일명)

1. 맨앞의글자가
d : 디렉토리 파일
- : 일반 파일
l : 심볼릭 링크
c : 문자 장치 파일
b : 블록 장치 파일
s : 소켓 파일
p : FIFO 파일

2. rwxr-xr-x (3 3 기억할것 !!)   
r : 파일에 대한 읽기 권한 
w  :  파일에 대한 쓰기 권한
x  : 파일에 대한 실행 권한 
- : 권한이 없음 !! 

접근권한이란
- 파일의 접근권한은 읽기 쓰기 실행 권한을 의미하는데 읽기 쓰기 실행 권한은 
대상 파일의 종류에 따라 다른 의미를 갖는다 !! 

-----------------------------------------------------------------------
파일 및 디렉토리 조작 실습
1. 현재 디렉토리를 확인하는 명령어를 실행하세요
2. 루트디렉토리에 directory 라는 디렉토리를 생성하세요
3. dirtory 디렉토리로 이동하세요
4. dirtory 디렉토리 안에 file1.txt file2.txt 두 개의 파일을 생성하세요
5. file1.txt 내용을 vi 창으로 hello world를 작성하고 확인하는 명령어를 실행하세요
6. file2.txt 내용을 vi 창으로 hello Linux를 작성하고 file2.txt 이름을 newfile.txt로 이름을 변경하세요
7. newfile.txt를 backup 디렉토리로 이동하세요
8. backup 디렉토리를 삭제하세요

========================================================================
## 251128 금 ##
리눅스는 다중사용자 시스템 !! 
- 파일 및 디렉토리에 대한 세부적인 권한 관리를 통해 
악의적인 행위를 방지 하기 위함 !! 

보안강화
1. 외부 공격 방지 
- 외부 공격자가 시스템에 침입하더라도 권한이 없는 중요한 부분에는 
접근하지 못하도록 막아 피해를 최소화 할 수 있다 !! 

2. 민감한 데이터를 보호할 수 있음 
- 서버에는 민감한 정보들이 포함되어 있을 수 있기에 접근 권한을 
적절히 설정하면 무단 열람 수정 삭제 등을 막을 수 있음 

d rwxr-xr-x   4  root    root       4096 Nov 24 21:10 test
파일타입  (파일권한)      (소유자) (그룹)       (마지막 수정 날짜)

r : 파일 읽기 권한
w : 파일 쓰기 권한
x : 파일 실행 권한
- : 권한없다 !! 
rwx r-x r-x
(소유자권한)   (그룹권한)       (기타권한)
소유자 : 파일의 주인으로 보통 그 파일을 만든 사용자 
그룹 : 소유자가 속한 그룹을 의미 
기타 : 소유자도 아니고 그룹에도 속하지않은 나머지 사용자들을 의미 

rwx rwx rwx :  소유자 그룹 기타 사용자 모두 읽기 쓰기 실행가능
rwx r-x r-x : 소유자만 읽기 쓰기 실행가능 그룹 기타사용자는 읽기 실행 가능  
rw- rw- r-- : 소유자와 그룹만 읽기 쓰기 가능 기타사용자는 읽기만 가능 
rw- r-- r-- : 소유자만 읽기 쓰기 가능 그룹과 기타 사용자는 읽기만 가능 
rw- r-- --- : 소유자만 읽기 쓰기 가능 그룹은 읽기만 가능 기타는 권한 없음 
rwx --- --- : 소유자만 읽기 쓰기 실행 가능 

chmod 
- 파일 혹은 디렉토리의 접근 권한을 변경하는 명령어
- 8진수를 이용한 방법 기호를 이용하는 방법 두가지가 있음 

8진수로 표현하세요 !!~~ 
rwxrwxrwx => 777
rwxr-xr-x => 755
rw-rw-r-- => 664
rw-r--r-- => 644
rw-r----- => 640
rwx------ => 700

기호를 통해서 권한을 부여하거나 변경할 대상을 지정할 수 있다 
대상기호
u(User) : 소유자
g(group) : 그룹
o(others) : 그 외 다른 사용자
a(all) : 모든 사용자 

연산기호
+ : 권한을 추가한다 
- : 권한을 제거한다 
= : 기존 권한을 지우고 새로 설정 

chmod u+w test1.txt => 소유자에게 쓰기 권한 추가 
chmod go-x test1.txt => 그룹과 다른 사용자에게 실행 권한을 박탈한다 

소유자 변경 : chown(change owner)
- 파일이나 디렉토리의 소유자를 변경할 때 사용한다
- chown 명령어를 이용하여 파일의 소유자를 변경하면 이전 소유자는 더 이상 
해당 파일의 소유자가 아니다 
-R 옵션은 디렉토리에 대해 사용할 수 있다 즉) 지정된 디렉토리 아래의 모든
파일과 하위 디렉토리에 대해서도 소유자를 변경한다 

그룹 변경 : chgrp(change group)
- 파일의 그룹을 변경할 수 있다 
- 파일의 소유자는 해당 파일의 그룹을 소유자가 속한 다른 그룹으로만 변경할 수 있다 
또한 슈퍼유저는 이 명령어를 자유롭게 사용가능 !! 

--------------------------------------------------
프로그램이란?
- 컴퓨터에서 어떤 작업을 위해 실행할 수 있는 정적인 상태의 파일을 말함 

프로세스(Process)
- 리눅스에서 프로세스는 실행 중인 프로그램을 나타내는 단위이다 
- 각각의 프로세스는 독립적으로 메모리와 시스템 리소스를 할당받는다 
- 리눅스는 다중 사용자, 다중 작업환경을 지원하므로 여러개의 프로세스가 
동시에 실행될 수 있다 
- 프로세스는 운영체제로부터 자원을 할당받아 cpu, 메모리, 네트워크 리소스를 사용할
수 있고 각 프로세스는 고유한 id값을 가지며 이를 통해 식별한다 !! 
ps : 프로세스 조회 
ps -e(all) : 모든 프로세스를 조회 
ps -ef(full-format) : 시스템에서 실행 중인 모든 프로세스를 자세하게 보여주는 명령어 
-ef : 시스템에서 실행중인 프로세스를 상세히 조회하는 옵션 

시스템 내에는 여러 개의 프로세스가 동시에 수행되고 있다 
시스템 내의 프로세스는 크게 시스템 프로세스와 사용자 프로세스로 구분된다 
시스템 프로세스
- 시스템 운영에 필요한 기능을 수행하는 프로세스 

사용자 프로세스
- 사용자의 명령 혹은 프로그램을 실행시켜 생성된 프로세스 

프로세스의 특징
- 각 프로세스는 부모 프로세스에 의해 생성되고 부모 프로세스의 아이드를 
PPID(Parent Process Identification) 이라고 한다 
- 프로세스는 각각 Code, Stack, Heap, Static 의 구조로 되어있고 
독립된 메모리 영역을 할당받는다 
- 다른 프로세스의 자원에 접근하려면 프로세스간 통신(IPC) 사용해야 한다 
IPC 통신
1. 소켓  : 네트워크를 통해 통신 
2. 메시지 큐 : 운영체제 커널이 메시지를 저장하고 전달 
3. 파이프 : 한 프로세스가 쓰고 다른 프로세스가 읽는 일방향 통신 
- 프로세스는 최소 하나 이상의 스레드를 포함한다 

Code 영역
- 프로그램의 실행코드가 저장되는 영역 
- 컴파일된 바이트 코드가 여기에 저장된다 

Stack 영역
- 함수 호출 시 생성되는 지역변수와 함수의 실행 정보를 저장하는 영역
- LIFO(후입선출) 구조로 동장

Heap 영역
- 동적으로 할당된 메모리가 저장되는 영역 
- c언어 같은 경우 malloc() 함수를 이용하고 자바는 new 연산자를 사용하여 
메모리를 할당한다 
- 개발자가 직접 메모리를 해제 하지 않으면 메모리 누수 위험이 있다 
메모리 누수가 발생하면 성능저하로 이어짐 

Static 영역
- 정적 변수가 저장되는 영역
- 프로그램 실행 중에도 값이 유지된다 

스레드(Thread)란
- 스레드는 프로세스 내에서 실행되는 여러 개의 작업 흐름이다.
각 프로세스는 하나 이상의 스레드를 가질 수 있고 이들은 같은 프로세스 공간을 
공유하면서 동시에 실행될 수 있다. 
- 여러 스레드는 프로세스 내에서 자원을 공유한다. 
- 최소 하나의 스레드를 가지고 실행되며 이를 메인 스레드라고 부른다 
그외에 추가적인 스레드를 생성하여 병렬 작업을 처리할 수 있다 

프로세스와 스레드의 연관관계
- 스레드는 프로세스의 실행 흐름을 나누는 역할을 하므로 
복잡한 작업을 병렬로 처리할 수 있게 만들어 준다 
- 스레드는 프로세스의 자원을 공유한다. 예를 들어 같은 프로세스 내에서 
여러 스레드가 메모리나 파일을 공유할 수 있다. 하지만 스레드 간에는 자원 충돌이 
발생할 수 있기에 이를 방지하는 동기화 기법이 필요하다  !!

==========================================================================
## 251201 월 ##
쉘(Shell) 이란
- 사용자가 입력하는 명령을 읽고 해석하여 실행시키는 명령어 처리기 역할 수행

하드웨어
- 하드웨어는 실질적으로 원하는 수행을 하기 위해 데이터가 물리적으로 
저장되어 있다

커널
- 커널은 운영체제의 핵심(Core)으로 하드웨어와 소프트웨어간의 인터페이스 
역할을 한다 

쉘과 커널관계
- 쉘을 사용자가 입력한 명령어를 해석하고 이를 커널에 전달하는 역할을 한다 
- 쉘을 통해 입력한 명령어를 해석하여 기계가 이해할 수 있는 표현으로 바꿔 전달해 주는 역할 

Linux 에서 사용하는 Shell 종류
본쉘(Bourne Shell) /bin/sh
- 본쉘은 가장 먼저 만들어진 쉘어 스티븐본에 의해 개발팀 최초의 유닉스 쉘로 sh로 표기함
- history 기능을 제공하지 않는다 

콘쉘(Korn Shell) /bin/ksh
- 본쉘의 확장판
- history 기능과 alias 기능이 추가됨 

bash쉘 /bin/bash
- 본쉘을 확장하여 개발한 쉘로 리눅스 뿐만아니라 맥 os에서 기본 쉘로 채택되어 사용되면서 
널리 보급됨 

C쉘 /bin/csh
- 쉘의 공통 핵심 기능 위에 C언어의 특징을 많이 포함하도록 만들어짐 
- BDS계열의 유닉스에서 많이 사용됨 

출력 명령 : echo 
- Bash쉘의 기본적인 출력명령으로 echo가 있다 
- 문자열, 변수 값 등을 출력하는데 사용한다 
- 유닉스 및 유닉스 계열 운영체제에서 지정한 문자열 또는 텍스트를 터미널에 
출력하는 명령어 
- 일반적으로 터미널 프롬프트 명령어나 쉘 스크립트, 배치파일에서 
화면이나 파일로 상황을 알리는 문자열을 출력할 때 사용한다 
- 쉘 스크립트의 변수나 시스템 환경변수를 확인 할 경우 주로 사용 


echo 명령어 기본 사용 : echo [옵션][텍스트 및 문자열]
- 리눅스에서 출력 명령어로 자주 쓰는 명령어이고 옵션 없이 사용할 수 있고 
다양한 옵션과 이스케이프 문자의 옵션을 이용하여 여러가지 방식으로 출력을 표현할 수 있다
- 리눅스 echo 명령어는 큰따옴표 없이도 문자열을 출력할 수 있지만 
특수 문자가 포함된 문자열이거나 긴 문자을 표현할 때는 쌍따옴표를 사용하여 출력한다 

echo 명령어 리다이렉션(입출력 재지정) 파일 생성 
- 입출력 재지정이란 일반적인 입력 출력을 사용하지 않고 파일로 입출력하겠다는 말 
- 리다이렉션을 통해 파일로부터 입력을 받고 파일로 출력하여 출력과 입력의 방향을 
변경할 수 있는 원리 

> (출력재지정연산자)
- 출력 재지정을 사용하면 명령어의 표준출력 내용을 모니터에 출력하는 대신 파일에 저장할 수 있다
만약 파일이 존재하지 않는다면 자동으로 생성되고 기존의 파일이 존재한다면 덮어쓰기를 실행한다.

>> (출력추가연산자)
- 출력 재지정을 사용한다면 기존 파일의 내용은 덮어쓰기를 하므로 기존 내용은 모두 사라짐
>> 기호를 이용한다면 명령어의 표준출력 내용을 모니터에 출력하는 대신에 기존 파일에 추가할 수 있다

grep 명령어
- 하위 폴더를 포함하여 존재하는 모든 파일에서 원하는 단어를 찾아주는 명령어 해당 단어를 포함하고 
있는 모든 행을 출력한다 

옵션
-w : 해당 문자열을 포함하는 줄들을 출력한다 
-n : 줄번호를 포함하여 출력한다 
-i : 대소문자 무시하여 해당 단어를 검색하여 출력한다 

|(Shift + 원표시)
- 파이프라인은 파이프라인 앞 명령어의 출력값을 파이프라인 뒤 명령어의 입력값으로 사용할 수 있게 
해준다. 
예시) ls -l | grep test1
ls -l 의 출력 결과를 파이프 뒤의 grep 명령어의 입력으로 전달된다 
ls -l의 출력에서 test1이 포함된 파일만 찾아서 출력한다 !! 

< (입력재지정연산자)
- 입력 재지정을 사용하면 명령어의 표준입력을 키보드에서 받는 대신 파일에서 받을 수 있다 

변수 선언 후 echo 명령어로 확인
- 쉘 환경 자체가 하나의 프로그래밍 인터프리터 처럼 동작하기 때문에 명령어 입력만으로도 
변수 선언과 사용이 가능함 
- 리눅스에서 사용되는 Bash 쉘은 단순히 명령어를 실행하는 것 뿐만 아니라 스크립트 언어처럼 
변수를 선언하고 사용할 수 있는 기능도 제공한다 
즉) 쉘 자체가 명령어를 해석하면서 변수도 처리할 수 있는 인터프리터 역할을 하기 때문에 즉시 
변수값이 저장되고 사용할 수 있다

echo 옵션 
-n : 개행하지 않고 출력
-e : 문자열에서 백슬레시 와 이스케이프 문자를 인식하여 출력
-E : 문자열에서 백슬래시와 이스케이프 문자를 무시하여 출력 (즉 하나의 문자열로 인식) 
\n, \t, \\, \b 

쉘 스크립트와 일반 프로그래밍 언어 비교 
쉘 스크립트에 존재하는 것
1. 변수 
2. 조건문 반복문 존재 
3. 함수 
4. 배열 

쉘 스크립트에 존재하지 않는것 
1. 포인터 
2. 클래스 
3. 상속 인터페이스 내부클래스 추상클래스 등 존재하지 않음(객체지향 아니라서) 

쉘 스크립트 변수
- 타 프로그래밍 언어에서처럼 쉘에서도 변수를 사용할 수 있다 
- 타입선언을 할 필요 없음 
- 모든 변수가 문자열을 저장하는 문자열 타입이라고 생각하면 된다 

